### **动态规划（Dynamic Programming, DP）全面详解（C++实现）**

---

## **1. 动态规划的核心思想**
动态规划是一种**分阶段解决问题**的算法思想，通过将复杂问题分解为**重叠子问题**，并存储子问题的解（记忆化），避免重复计算，从而显著提高效率。其核心特点包括：
- **最优子结构**：问题的最优解包含子问题的最优解。
- **重叠子问题**：子问题被重复计算多次。
- **状态转移方程**：定义如何从子问题的解推导出当前问题的解。

---

## **2. 动态规划的解题步骤**
1. **定义状态**：明确问题的状态表示（如 `dp[i]` 或 `dp[i][j]`）。
2. **初始化状态**：设置初始条件（如 `dp[0] = 0`）。
3. **状态转移方程**：写出递推关系式。
4. **计算顺序**：确定填表顺序（自底向上或自顶向下）。
5. **返回结果**：从状态表中提取最终解。

---

## **3. 经典问题与C++实现**

### **问题1：斐波那契数列**
**问题描述**：计算第 `n` 个斐波那契数（`F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)`）。

#### **方法1：递归（暴力解法）**
```cpp
int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```
**缺点**：时间复杂度 `O(2^n)`，存在大量重复计算。

#### **方法2：动态规划（自底向上）**
```cpp
int fib(int n) {
    if (n <= 1) return n;
    int dp[n + 1];
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
**优化**：时间复杂度 `O(n)`，空间复杂度 `O(n)`。

#### **方法3：动态规划（空间优化）**
```cpp
int fib(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```
**优化**：空间复杂度 `O(1)`。

---

### **问题2：背包问题（0-1 Knapsack）**
**问题描述**：给定物品重量 `w[]` 和价值 `v[]`，背包容量 `W`，求最大价值。

#### **状态定义**
- `dp[i][j]`：前 `i` 个物品在容量 `j` 下的最大价值。

#### **状态转移方程**
```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])  // 选或不选第i个物品
```

#### **C++实现**
```cpp
int knapsack(int W, vector<int>& w, vector<int>& v) {
    int n = w.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= W; j++) {
            if (w[i-1] <= j) {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1]);
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][W];
}
```
**优化**：可压缩为一维数组 `dp[j]`，空间复杂度 `O(W)`。

---

### **问题3：最长公共子序列（LCS）**
**问题描述**：给定两个字符串 `s1` 和 `s2`，求它们的最长公共子序列长度。

#### **状态定义**
- `dp[i][j]`：`s1[0..i-1]` 和 `s2[0..j-1]` 的LCS长度。

#### **状态转移方程**
```
if (s1[i-1] == s2[j-1]) 
    dp[i][j] = dp[i-1][j-1] + 1;
else 
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
```

#### **C++实现**
```cpp
int lcs(string s1, string s2) {
    int m = s1.size(), n = s2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```
**时间复杂度**：`O(mn)`。

---

## **4. 动态规划的两种实现方式**
### **(1) 自底向上（迭代）**
- 使用循环填充DP表（如斐波那契数列、背包问题）。
- 适合大多数问题，效率高。

### **(2) 自顶向下（记忆化递归）**
- 递归 + 缓存（Memoization）。
- 代码更直观，但可能有栈溢出风险。

#### **示例：斐波那契（记忆化递归）**
```cpp
int fibMemo(int n, vector<int>& memo) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];
    memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
    return memo[n];
}

int fib(int n) {
    vector<int> memo(n + 1, -1);
    return fibMemo(n, memo);
}
```

---

## **5. 动态规划的应用场景**
| 问题类型               | 经典问题                     |
|------------------------|-----------------------------|
| 序列问题               | 最长递增子序列（LIS）        |
| 路径问题               | 最小路径和（Grid DP）        |
| 字符串匹配             | 编辑距离（Edit Distance）   |
| 背包问题               | 0-1背包、完全背包           |
| 区间DP                | 矩阵链乘法（Matrix Chain）  |

---

## **6. 动态规划的优化技巧**
1. **空间压缩**：如背包问题用一维数组代替二维数组。
2. **状态压缩**：如位运算优化（TSP问题）。
3. **斜率优化**：优化某些递推式（如单调队列）。
4. **四边形不等式**：优化区间DP。

---

## **7. 总结**
- 动态规划的核心是**状态定义**和**状态转移方程**。
- 优先考虑**自底向上**的迭代方法，避免递归开销。
- 经典问题（斐波那契、背包、LCS）是理解DP的基础。
- 优化技巧（空间压缩、记忆化）能大幅提升效率。

掌握动态规划需要大量练习，建议从简单问题入手，逐步挑战更复杂的题目！