### **问题描述**
给定一个字符串 `s`，由若干单词组成，单词之间用空格分隔（可能包含前导或后缀空格）。要求返回字符串中**最后一个单词的长度**。单词定义为**仅由字母组成、不包含空格的最大子字符串**。

### **示例**
```plaintext
输入: s = "Hello World"
输出: 5
解释: 最后一个单词是 "World"，长度为 5。

输入: s = "   fly me   to   the moon  "
输出: 4
解释: 最后一个单词是 "moon"，长度为 4。
```

### **解题思路**
1. **去除末尾空格**：首先需要忽略字符串末尾的空格，避免干扰最后一个单词的识别。
2. **从后向前遍历**：从字符串末尾开始向前遍历，直到遇到第一个空格或到达字符串开头。
3. **计算单词长度**：在遍历过程中统计非空格字符的数量，直到遇到空格或字符串起始位置。

### **C++ 实现**
```cpp
#include <string>
using namespace std;

int lengthOfLastWord(string s) {
    int length = 0;
    int i = s.size() - 1;  // 从字符串末尾开始

    // 跳过末尾的空格
    while (i >= 0 && s[i] == ' ') {
        i--;
    }

    // 计算最后一个单词的长度
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }

    return length;
}
```

### **代码解析**
1. **初始化变量**
   - `length`：用于记录最后一个单词的长度，初始化为 `0`。
   - `i`：从字符串末尾开始遍历的索引，初始值为 `s.size() - 1`。

2. **跳过末尾空格**
   ```cpp
   while (i >= 0 && s[i] == ' ') {
       i--;
   }
   ```
   - 如果 `s[i]` 是空格，则继续向前移动 `i`，直到遇到非空格字符或到达字符串开头。

3. **计算最后一个单词的长度**
   ```cpp
   while (i >= 0 && s[i] != ' ') {
       length++;
       i--;
   }
   ```
   - 从当前 `i` 开始，向前遍历并统计非空格字符的数量，直到遇到空格或字符串开头。

4. **返回结果**
   - `length` 即为最后一个单词的长度。

### **测试示例**
```cpp
#include <iostream>
int main() {
    cout << lengthOfLastWord("Hello World") << endl;       // 输出 5
    cout << lengthOfLastWord("   fly me   to   the moon  ") << endl;  // 输出 4
    cout << lengthOfLastWord("luffy is still joyboy") << endl;  // 输出 6
    return 0;
}
```

### **复杂度分析**
- **时间复杂度**：`O(n)`，其中 `n` 是字符串的长度。最坏情况下需要遍历整个字符串两次（跳过空格 + 计算单词长度）。
- **空间复杂度**：`O(1)`，仅使用常数空间存储变量。

### **边界情况处理**
1. **字符串全为空格**
   ```cpp
   s = "     ";
   ```
   - 跳过所有空格后 `i = -1`，`length` 保持 `0`，返回 `0`。

2. **字符串仅有一个单词**
   ```cpp
   s = "Hello";
   ```
   - 跳过空格后 `i` 指向 `'o'`，计算长度 `5`，返回 `5`。

3. **字符串末尾有多个空格**
   ```cpp
   s = "Hello World     ";
   ```
   - 跳过末尾空格后 `i` 指向 `'d'`，计算 `"World"` 的长度 `5`，返回 `5`。

### **优化思路**
- **单次遍历**：可以合并跳过空格和计算长度的步骤，减少遍历次数。
  ```cpp
  int lengthOfLastWord(string s) {
      int length = 0;
      for (int i = s.size() - 1; i >= 0; i--) {
          if (s[i] != ' ') {
              length++;
          } else if (length > 0) {  // 遇到空格且已经统计过字符
              return length;
          }
      }
      return length;
  }
  ```
  - 如果 `s[i]` 不是空格，增加 `length`。
  - 如果 `s[i]` 是空格且 `length > 0`，说明最后一个单词已经统计完毕，直接返回 `length`。

### **总结**
- **核心思想**：从后向前遍历，先跳过末尾空格，再统计最后一个单词的长度。
- **关键点**：正确处理前导/后缀空格，避免干扰单词识别。
- **适用场景**：适用于需要从字符串末尾提取信息的类似问题。